@Entity 테이블에 필수

@ManyToMany 다대다 관계에서 사용. 다대다 관계는 중간 매핑 테이블이 필요하며 실무에서 사용하지 않음.
@JoinTable(name = "category_item", //테이블명
           joinColumns = @JoinColumn(name = "category_id"),    //fk 칼럼
           inverseJoinColumns = @JoinColumn(name = "item_id")) //fk 칼럼

Team class
@OneToMany(mappedBy = "team")
private List<User> userList = new ArrayList<>();

User class
@ManyToOne
@JoinColumn(name = "team_id")
private Team team;

------------------------------------------------------------------------------------------------------------------------------

1. 설계시 n:m 지양 -> 중간테이블을 두고 1:n n:1 로 풀어서 설계
2. 동일 트랜잭션 내에선 entity 객체는 동일하다고 판단
3. getter 는 열어두되 setter 는 꼭 필요할때만 선언
* setter 를 모두 열어둘 경우 entity cud 에 대한 처리가 어디서 이뤄지는지 추적 어려움


// h2 설치경로 ~/bin h2.sh 실행 후 서버 띄워야 JPA 관련 에러 발생하지 않음
// h2 에서 테이블명세보기: show columns from category;

// 실무에서 @Getter 는 열어두고 @Setter 는 필요시에만 사용

------------------------------------------------------------------------------------------------------------------------------

fetch = fetchType.EAGER  or LAZY
EAGER : 연관관계에 있는 데이터를 즉시 로딩 (Order 를 조회했을 경우 @ManyToOne Member 를 같이 가져옴
    -> n + 1 문제 발생 ( ex: select * from order where order_date between  sysdate and sysdate-1 JPQL 수행 결과가 100건인 경우
                            Order 의 연관관계인 Member 를 100개(n) + Order쿼리(1) = n+1 문제 발생 )
LAZY : 연관관계에 있는 데이터를 지연 로딩
    -> 조회한 테이블만 조회. EAGER를 부분적으로 사용하고 싶은경우(ORDER 조회시 연관관계인 MEMBER를 함께 가져오고 싶은경우), fetch join 사용
* @ManyToOne @OneToOne (@XToOne) 은 default fetchType 이 EAGER.
* @OneToMany (@XToMany) 는 default fetchType 이 LAZY.

